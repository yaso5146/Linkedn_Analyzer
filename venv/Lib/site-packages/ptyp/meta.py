# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/04_meta.ipynb.

# %% auto 0
__all__ = ['ProtocolBaseMeta', 'ProtocolMeta', 'ProtoType', 'AliasMeta', 'Alias', 'NotMeta', 'Not', 'OptionalMeta', 'Opt']

# %% ../nbs/04_meta.ipynb 6
import os, io, inspect
from inspect import signature
from abc import abstractmethod
from math import isnan as pyisnan, nan as pynan
from operator import eq, is_
from functools import wraps, singledispatch
from contextlib import redirect_stderr

# %% ../nbs/04_meta.ipynb 8
from types import NoneType, FunctionType
from typing import (
    Self, Type, TypeVar, TypeGuard, TypeAlias, ParamSpec,
    Callable, Iterable, Optional, Protocol, _ProtocolMeta, 
    Any, Set, Dict, List, Tuple, Union, ClassVar, Generic, Literal,
    get_args, get_origin, runtime_checkable, overload, 
)

# %% ../nbs/04_meta.ipynb 10
#| export


# %% ../nbs/04_meta.ipynb 12
#| export


# %% ../nbs/04_meta.ipynb 14
from .cons import ALLATTRS
from ptyp.type import (
    T, P, Types, TypeLike, Guard,
    TGuard, IterT, IterFunc, NanGuard, IterGuard, IterTGuard,
    IterStr, AttrGuards
)

from ptyp.grds import (
   aliascheck
)

from ptyp.util import (
    filtkwds, popget, classvars, getname,
    argname, argsname, classname, unionify,
    opttypes, guardtype, qualname
)

# %% ../nbs/04_meta.ipynb 16
class ProtocolBaseMeta(_ProtocolMeta):
    '''Base metaclass for creating protocol classes with custom type checking.

    This metaclass provides mechanisms to define custom type checks for classes 
    and to dynamically create classes with these checks.

    Attributes
    ----------
    types : Types
        A tuple of types that the class will check against.
    attrs : dict
        A dictionary of attributes that the class will check against.

    Methods
    -------
    getbtype()
        Abstract method to get the base type of the protocol.
    check(obj)
        Checks if an object conforms to the protocol.
    makeguard()
        Creates a guard method for the protocol.
    makebases(cls)
        Determines the base classes for a new class instance.
    default_kwds(**kwargs)
        Provides default keyword arguments for class creation.
    classname(cls, clsname)
        Gets the class name.
    qualname(cls, *types, clsname, prefix, suffix, dropnone)
        Generates a qualified name for the class.
    settypes(cls, *types, clsname, prefix, suffix, dropnone)
        Sets the types for the class.
    setattrs(cls, attrs)
        Sets the attributes for the class.
    setbtype(cls, btype)
        Sets the base type for the class.
    __call__(cls, *args, **kwargs)
        A callable method that enables the dynamic creation of classes.
    '''
      
    types: IterT = tuple() # types to check
    guards: IterFunc = tuple()    # additional guards to check
    attrs: dict = dict()          # attributes compare values against
    hasattrs: IterStr = tuple()   # attributes to ensure exist
    allattrs: IterStr = ALLATTRS  # attributes to check that values are all the same if object is iterable
    mapattrs: AttrGuards = dict() # attributes to check with custom functions
    clsattrs: ClassVar[tuple[str]] = ('types', 'guards', 'attrs', 'hasattrs', 'allattrs', 'mapattrs')
    
    
    def check(cls, obj) -> TypeGuard[T]:
        '''Class method to check if an object conforms to the protocol.

        Parameters
        ----------
        obj : Any
            The object to be checked against the protocol.

        Returns
        -------
        Guard
            The result of the type checking.
        '''
        return aliascheck(obj, cls.types, cls.guards, cls.attrs, cls.hasattrs, cls.allattrs, cls.mapattrs)
    
    @classmethod
    def makeguard(mcls) -> TGuard:
        '''Class method to create a guard method for the protocol.

        Returns
        -------
        Guard
            A class method acting as a guard for the protocol.
        '''
        def guard(cls, obj) -> TGuard:
            return cls.check(obj)
        return classmethod(guard)
        return classmethod(lambda cls, obj: mcls.check(cls, obj))
    
    def __instancecheck__(self, ins) -> Guard:
        '''Instance method to check if an instance conforms to the protocol.

        Parameters
        ----------
        ins : Any
            The instance to be checked.

        Returns
        -------
        Guard
            The result of the instance checking.
        '''
        return self.check(ins)
    
    @classmethod
    def makebases(mcls: Type[T], cls: T) -> Types:
        '''Class method to determine the base classes for a new class instance.

        Parameters
        ----------
        cls : type
            The class for which the base classes are to be determined.

        Returns
        -------
        tuple
            A tuple of base classes.
        '''
        btype = mcls.getbtype()
        bases = (cls, btype) if btype not in cls.__bases__ else (cls, )
        return bases
    
    @classmethod
    def metadict(mcls, *args, **kwargs) -> dict:        
        clsattrs = getattr(mcls, 'clsattrs', ('types', 'guards', 'attrs', 'hasattrs', 'allattrs', 'mapattrs'))
        clsavars = classvars(mcls, *clsattrs, **kwargs)
        # clsavars['check'] = mcls.makeguard()
        return clsavars
    
    @classmethod
    def default_kwds(cls, **kwargs) -> dict:
        '''Class method to provide default keyword arguments for class creation.

        Parameters
        ----------
        **kwargs : dict
            Keyword arguments for class creation.

        Returns
        -------
        dict
            A dictionary of default keyword arguments.
        '''
        fncattrs = dict(zip(('alt', 'prefix', 'suffix', 'dropnone'), (None, '', '', True)))
        return dict((k, kwargs.get(k, v)) for k, v in fncattrs.items())
        
    def __new__(mcls, name, bases: tuple = (), dct: dict = dict(), **kwargs):
        '''Class method to create a new class instance.

        Parameters
        ----------
        name : str
            The name of the new class.
        bases : tuple
            A tuple of base classes.
        dct : dict
            A dictionary of class attributes.
        **kwargs : dict
            Additional keyword arguments.

        Returns
        -------
        type
            A new class instance.
        '''
        dct.update(**mcls.metadict(**kwargs))
        new = super().__new__(mcls, name, bases, dct)
        
        kwargs.update(mcls.default_kwds(**kwargs))        
        types = dct.get('types')
        new.__qualname__ = (qualname := new.qualname(*types, **kwargs))
        new.setqualname(*types, name=qualname, **filtkwds(new.qualname, **kwargs))\
            .settypes(*types, **filtkwds(new.gettypes, **kwargs))\
            .setguards(new.getguards()).setattrs(new.getattrs())\
            .sethasattrs(new.gethasattrs()).setallattrs(new.getallattrs())\
            .setmapattrs(new.getmapattrs())
        return new
    
    @classmethod
    def __init_subclass__(cls, *args, **kwargs):
        '''Class method to initialize a subclass of the protocol.'''
        super().__init_subclass__(*args, **kwargs)
        kwargs.update(**cls.default_kwds(**kwargs))
        dct = cls.metadict(*args, **kwargs)
        for attr, aval in dct.items(): 
            setname = f'set{attr}'
            setfunc = getattr(cls, setname, lambda v: setattr(cls, attr, v))
            # print(setname, attr, aval, setfunc)
            if attr == 'types': setfunc(*aval, **filtkwds(cls.settypes, **kwargs))
            else: setfunc(aval)
            
    def classname(cls, alt: str = None) -> str:
        '''Class method to get the class name.

        Parameters
        ----------
        clsname : StrBool
            The class name or a boolean indicating if the class name should be used.

        Returns
        -------
        StrBool
            The class name or a boolean value.
        '''
        return classname(cls, alt)
    
    def qualname(
        cls, *types: Types, prefix: str = '', suffix: str = '', 
        dropnone: bool = True, alt: str = None, **kwargs
    ) -> str:
        '''Class method to generate a qualified name for the class.

        Parameters
        ----------
        *types : Types
            A tuple of types.        
        prefix : str, optional
            A prefix for the qualified name.
        suffix : str, optional
            A suffix for the qualified name.
        dropnone : bool, optional
            A flag to indicate whether None types should be dropped.

        Returns
        -------
        str
            The qualified name of the class.
        '''
        kwds = filtkwds(cls.qualname, **kwargs)
        kwds.pop('types', None)
        return qualname(cls, *types, alt=alt, prefix=prefix, suffix=suffix, dropnone=dropnone)
    
    @classmethod
    def getqualname(cls) -> str: 
        return getattr(cls, '__qualname__', getname(cls))
    
    @classmethod
    def gettypes(cls) -> IterT:        
        return getattr(cls, 'types', tuple())
    
    @classmethod
    def getguards(cls) -> IterFunc: 
        return getattr(cls, 'guards', tuple())
    
    @classmethod
    def getattrs(cls) -> dict: 
        return getattr(cls, 'attrs', dict())
    
    @classmethod
    def gethasattrs(cls) -> IterStr: 
        return getattr(cls, 'hasattrs', tuple())
    
    @classmethod
    def getallattrs(cls) -> IterStr: 
        return getattr(cls, 'allattrs', ALLATTRS)
    
    @classmethod
    def getmapattrs(cls) -> AttrGuards: 
        return getattr(cls, 'mapattrs', dict())
    
    @classmethod
    def setqualname(cls, *types, name: str = None, **kwargs) -> Type[Self]: 
        if name is None or name == '':
            kwds = filtkwds(cls.qualname, **kwargs)
            kwds.pop('types', None)
            name = cls.qualname(cls, *types, **kwds)
        setattr(cls, '__qualname__', name)
        return cls    
    
    @classmethod
    def settypes(cls, *types, dropnone: bool = True, **kwargs) -> Type[Self]:        
        '''Class method to set the types for the class.

        Parameters
        ----------
        *types : Types
            A tuple of types.        
        prefix : str, optional
            A prefix for the qualified name.
        suffix : str, optional
            A suffix for the qualified name.
        dropnone : bool, optional
            A flag to indicate whether None types should be dropped.
        '''
        # print('settypes', types, dropnone, kwargs)
        setattr(cls, 'types', opttypes(types, dropnone))
        return cls
    
    @classmethod
    def setguards(cls, guards: IterFunc = tuple()) -> Type[Self]:
        # print('setguards', guards)
        setattr(cls, 'guards', guards)
        return cls
    
    @classmethod
    def setattrs(cls, attrs: dict = dict()) -> Type[Self]:
        setattr(cls, 'attrs', attrs)
        return cls
    
    @classmethod
    def sethasattrs(cls, hasattrs: IterStr = tuple()) -> Type[Self]:
        setattr(cls, 'hasattrs', hasattrs)
        return cls
    
    @classmethod
    def setallattrs(cls, attrs: IterStr = ALLATTRS) -> Type[Self]:
        setattr(cls, 'allattrs', attrs)
        return cls
    
    @classmethod
    def setmapattrs(cls, attrs: AttrGuards = dict()) -> Type[Self]:
        setattr(cls, 'mapattrs', attrs)
        return cls
        
    @classmethod
    @abstractmethod
    def getbtype(cls) -> object:
        '''Abstract class method to get the base type of the protocol.
        
        Returns
        -------
        None
            Placeholder return type for the abstract method.
        '''
        return None
    
    @classmethod
    def setbtype(cls, btype: Type = None) -> Type[Self]:
        '''Class method to set the base type for the class.

        Parameters
        ----------
        btype : Type, optional
            The base type to be set for the class.
        '''
        setattr(cls, 'btype', btype)
        return cls
        
    @overload
    def __call__(cls: 'ProtocolBaseMeta', base: type, *dtypes: Types, **kwargs) -> TypeGuard[T]: ...
    @overload
    def __call__(cls: type, instance: object) -> TypeGuard[T]: ...
    @overload
    def __call__(cls: type, *instances: tuple[object, ...]) -> TypeGuard[T]: ...
    @overload
    def __call__(cls: type, *args, **kwargs) -> TypeGuard[T]: ...    
    def __call__(cls: type, *args, **kwargs) -> TypeGuard[T]:
        '''Overloaded callable method that enables dynamic creation and type checking of classes.

        Parameters
        ----------
        *args : variable
            Variable arguments for different use cases.
        **kwargs : dict
            Keyword arguments for different use cases.

        Returns
        -------
        TypeGuard[T]
            Depending on the arguments, either performs type checking or creates a new class instance.
        '''  
        if len(cls.types) > 0 and len(args) > 0 and not isinstance(args[0], type) or args[0] is NoneType:            
            if len(args) == 1: 
                # print(cls, cls.check, inspect.signature(cls.check), args)
                return cls.check(args[0])
            if all(not inspect.isclass(i) for i in args):
                # print('checking', cls, args)
                return tuple(cls.check(i) for i in args)
            # print('has types and args', args)
            return cls.check(args[0])
    
        dtypes = args
        def decorator(kls):
            '''Decorator to apply negation to a class.'''
            clsname = kwargs.get('clsname', getname(kls))
            bases = cls.makebases(kls)
            cdict = dict()
            new = cls.__class__(clsname, bases, cdict, types=dtypes, **kwargs)
            return new
        return decorator

# %% ../nbs/04_meta.ipynb 18
class ProtocolMeta(ProtocolBaseMeta):
    '''Metaclass for creating protocol classes with a specific base type.

    Inherits from ProtocolBaseMeta and provides a specific base type for the 
    protocol classes created using this metaclass.

    Example
    -------
    >>> @Alias(str, bytes)
    ... class StrBytes: ...
    >>> StrBytes('hello')  # Checks if 'hello' is an instance of str or bytes.
    '''
    @classmethod
    def getbtype(cls): return ProtoType

@runtime_checkable
class ProtoType(Protocol):
    '''Base protocol class with custom type checking capabilities.

    This class provides mechanisms for custom type checking and can be used as a 
    base class for creating protocol types.

    Examples
    --------
    >>> @Not(str, bytes)
    ... class NotStrBytes: ...
    >>> NotStrBytes(123)  # Checks if 123 is not an instance of str or bytes.

    ### Subclassing Example
    >>> class MyType(ProtoType, types=(int, float)):
    ...     \'\'\'Custom type that checks against int and float\'\'\'
    >>> MyType(10)  # Checks if 10 is an instance of int or float.
    '''

# %% ../nbs/04_meta.ipynb 20
class AliasMeta(ProtocolMeta):
    '''Metaclass for creating alias classes with custom type checking.

    Inherits from ProtocolBaseMeta and provides a specific base type for the 
    alias classes created using this metaclass.

    Example
    -------
    >>> @Alias(str, bytes)
    ... class StrBytes: ...
    >>> StrBytes('example')  # Checks if 'example' is an instance of str or bytes.
    ''' 
    @classmethod
    def getbtype(cls): return Alias

@runtime_checkable
class Alias(ProtoType, Protocol, metaclass=AliasMeta):
    '''Class representing an alias with custom type checking.

    Inherits from ProtoType and Protocol, and is created using the AliasMeta 
    metaclass. It represents an alias with specific type checking behavior.

    Example
    -------
    >>> @Alias(str, bytes)
    ... class StrBytes: ...
    >>> StrBytes(b'bytes')  # Checks if b'bytes' is an instance of str or bytes.
    '''

# %% ../nbs/04_meta.ipynb 22
class NotMeta(ProtocolMeta):
    '''Metaclass for creating negation classes with custom type checking.

    Inherits from ProtocolBaseMeta and overrides certain methods to provide 
    negation logic in type checking for the classes created using this metaclass.

    Example
    -------
    >>> @Not(str, bytes)
    ... class NotStrBytes: ...
    >>> NotStrBytes(['not', 'str', 'or', 'bytes'])  # Checks if list is not an instance of str or bytes.
    '''
    @classmethod
    def getbtype(cls): return Not

    @classmethod
    def default_kwds(cls, **kwargs) -> dict:
        kwds = super().default_kwds(**kwargs)
        kwds['prefix'] = '~'
        return kwds
    
    def check(self, obj) -> Guard:
        return not aliascheck(obj, self.types, self.guards, self.attrs, self.hasattrs, self.allattrs, self.mapattrs)
        # return not aliascheck(obj, self.types, self.attrs)
    
@runtime_checkable
class Not(ProtoType, Protocol, metaclass=NotMeta):
    '''Class representing a negation with custom type checking.

    Inherits from ProtoType and Protocol, and is created using the NotMeta 
    metaclass. It represents a negation type with specific type checking behavior.

    Example
    -------
    >>> @Not(str, bytes)
    ... class NotStrBytes: ...
    >>> NotStrBytes(100)  # Checks if 100 is not an instance of str or bytes.
    '''

# %% ../nbs/04_meta.ipynb 24
class OptionalMeta(ProtocolMeta):
    '''Metaclass for creating optional type classes with custom type checking.

    Inherits from ProtocolBaseMeta and modifies the creation process to include 
    NoneType in the types for the classes created using this metaclass.

    Example
    -------
    >>> @Opt(str)
    ... class StrQ: ...
    >>> StrQ(None)  # Checks if None is an instance of str or NoneType.
    >>> StrQ('optional')  # Checks if 'optional' is an instance of str or NoneType.
    '''
    @classmethod
    def getbtype(cls): return Opt

    @classmethod
    def default_kwds(cls, **kwargs) -> dict:
        kwds = super().default_kwds(**kwargs)
        kwds['prefix'] = '?'        
        return kwds
    
    def __new__(mcls, name, bases, dct, **kwargs):
        '''Create a new class instance.'''
        types = kwargs.pop('types', tuple())
        for ntype in (None, ):
            if ntype not in types:
                types += (ntype, )
        dct['types'] = types
        new = super().__new__(mcls, name, bases, dct, types = types, **kwargs)
        return new
    
@runtime_checkable
class Opt(ProtoType, Protocol, metaclass=OptionalMeta):
    '''Class representing an optional type with custom type checking.

    Inherits from ProtoType and Protocol, and is created using the OptionalMeta 
    metaclass. It represents an optional type with specific type checking behavior.

    Example
    -------
    >>> @Opt(int)
    ... class IntQ: ...
    >>> IntQ(None)  # Checks if None is an instance of int or NoneType.
    >>> IntQ(42)  # Checks if 42 is an instance of int or NoneType.
    '''
