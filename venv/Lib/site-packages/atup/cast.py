# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/02_cast.ipynb.

# %% auto 0
__all__ = ['isdict', 'notnone', 'istuple', 'isiterable', 'isdictiter', 'type_casting_config', 'typeflags', 'isneedcast',
           'item2tup', 'cast2tup', 'need2tup', 'atup2tup', 'vdic2tup', 'mapneeds']

# %% ../nbs/02_cast.ipynb 6
from functools import wraps, partial

# %% ../nbs/02_cast.ipynb 8
from typing import (Any, Optional, TypeGuard, Iterable,)

# %% ../nbs/02_cast.ipynb 10
#| export


# %% ../nbs/02_cast.ipynb 12
#| export

# %% ../nbs/02_cast.ipynb 14
from .atyp import dictiters, DictIters, Types, NeedCast, TypeCastingConfig
from .flag import TypeFlag

# %% ../nbs/02_cast.ipynb 16
def isdict(x) -> TypeGuard[dict]:
    '''Check if `x` is a `dict`.'''
    return isinstance(x, dict)

def notnone(x) -> TypeGuard[Any]:
    '''Check if `x` is not `None`.'''
    return not (x is None)

def istuple(x) -> TypeGuard[tuple]:
    '''Check if `x` is an `tuple`.'''
    return isinstance(x, tuple)

def isiterable(x) -> TypeGuard[Iterable]:
    '''Check if `x` is an `iterable`.'''
    return isinstance(x, (Iterable, ))

def isdictiter(x) -> TypeGuard[DictIters]:
    '''Check if `x` is a `dict_keys`, `dict_values`, or `dict_items`.'''
    return isinstance(x, dictiters)

# %% ../nbs/02_cast.ipynb 18
@wraps(TypeFlag.asdict)
def type_casting_config(
    __list: bool = False,
    __tuple: bool = True,
    __range: bool = True,
    __dict: bool = False,
    __dict_keys: bool = True,
    __dict_values: bool = True,
    __dict_items: bool = True,
    __dictiters: bool = None,
    __generator: bool = True,
    **kwargs: TypeCastingConfig
) -> TypeCastingConfig:
    if __dictiters == False: __dict_keys = __dict_values = __dict_items = False
    elif __dictiters == True: __dict_keys = __dict_values = __dict_items = True
    elif all((__dict_keys, __dict_values, __dict_items)): __dictiters = True
    else: __dictiters = False
    
    kwargs.update(dict(
        __list=__list, __tuple=__tuple, __range=__range, __dict=__dict,
        __dict_keys=__dict_keys, __dict_values=__dict_values, __dict_items=__dict_items,
        __dictiters=__dictiters, __generator=__generator
    ))
    constructor = partial(TypeFlag.asdict, **kwargs)
    return constructor(**kwargs)

# %% ../nbs/02_cast.ipynb 20
def typeflags(
    types: Optional[Types] = None,
    extra: Optional[Types] = None,
    **kwargs: TypeCastingConfig
) -> Types:
    '''Generate a tuple of types to use in `instancecheck` based on boolean flags.
    
    Parameters
    ----------
    types: tuple[type, ...], optional
        Base types to check.
        
    extra: tuple[type, ...], optional
        Additional types to check.
    
    Returns
    -------
    tuple[type, ...]
        A tuple of types to use in `instancecheck`.
        
    See Also
    --------
    type_casting_config: Generate a `TypeCastingConfig` instance with default values.
    TypeCastingConfig.make : Generate a tuple of types to use in `instancecheck` based on boolean flags.
    '''
    types = (types or tuple()) + (extra or tuple())
    known: TypeCastingConfig = type_casting_config(**kwargs)
    return TypeFlag.flagged(**known)

# %% ../nbs/02_cast.ipynb 23
def isneedcast(x, __index: int = 0, __useindex: bool = False, **kwargs: TypeCastingConfig) -> TypeGuard[NeedCast]:
    '''Check if `x` is either a `tuple`, `range`, `dict_keys`, `dict_values`, or `dict_items`.'''
    kwargs.update(__index=__index, __useindex=__useindex)
    types = (tuple, ) + typeflags(**kwargs)
    if __index == 0 and __useindex or not __useindex: return isinstance(x, types)
    return False

# %% ../nbs/02_cast.ipynb 28
def item2tup(arg: tuple | Any) -> tuple:
    '''Convert a single argument `arg` to a `tuple`. If `arg` is `Iterable`, it is returned as a tuple, 
    otherwise it is returned as a single element tuple.
    
    Examples
    --------
    >>> item2tup(1)
    (1,)
    >>> item2tup((1, 2))
    (1, 2)
    '''
    if isiterable(arg): return tuple(arg)
    return (arg, )

def cast2tup(arg: tuple | Any) -> tuple:
    '''Cast a single argumetn `arg` to a `tuple`. If `arg` is already a `tuple`, it is returned as is, 
    otherwise it is cast to tuple.
    
    Notes
    -----
    This function is similar to `item2tup` but it does not check if `arg` is an `Iterable`. It simply
        casts `arg` to a `tuple`.
    
    Raises
    ------
    TypeError
        If `arg` is not castable to a `tuple`. i.e. `arg` is not an `Iterable`.
    
    Examples
    --------
    >>> cast2tup(1)
    TypeError: 'int' object is not iterable
    >>> cast2tup((1, 2))
    (1, 2)
    >>> cast2tup(dict(a=1, b=2))
    ('a', 'b')
    >>> cast2tup('ab')
    ('a', 'b')
    '''
    return arg if istuple(arg) else tuple(arg)

def need2tup(item: NeedCast | Any, __index: int = 0,  __useindex: bool = False, **kwargs: TypeCastingConfig) -> tuple | Any:
    '''Checks if `item` needs to be cast to a `tuple` and casts it if necessary, otherwise returns `item` as is.
    
    Parameters
    ----------
    item : Any
        The item to check if it needs to be cast to a `tuple`.
        
    __index : int, default: 0
        The index of the item in the sequence. This is used to determine if the item is the first item in the sequence.
        
    __useindex : bool, default: False
        If `True`, the index of the item is used to ensure only the first item in the sequence is cast to a `tuple`.
        Otherwise, all items are cast to a `tuple` if necessary.
        
    **kwargs : TypeCastingConfig
        Additional keyword arguments to pass to `isneedcast`.
        
    Returns
    -------
    tuple | Any
        If `item` needs to be cast to a `tuple`, it is cast and returned, otherwise `item` is returned as is.
        
    Examples
    --------
    >>> need2tup(1)
    1
    >>> need2tup((1, 2))
    (1, 2)
    >>> need2tup(dict(a=1, b=2))
    {'a': 1, 'b': 2}
    >>> need2tup(dict(a=1, b=2), __dict=True)
    ('a', 'b')
    >>> need2tup(dict(a=1, b=2).keys())
    ('a', 'b')
    >>> need2tup(dict(a=1, b=2).keys(), __dict_keys=False)
    dict_keys(['a', 'b'])
    >>> need2tup('ab')
    'ab'
    '''
    kwargs.update(__index=__index, __useindex=__useindex)
    if isneedcast(item, **kwargs): return tuple(item)
    return item


def atup2tup(*args: tuple) -> tuple:
    '''A convenience function to accept variadic arguments i.e. 
    an arguments's tuple (`atup`) and ensure that they are represented 
    as a single `tuple`.'''
    if istuple(args): return args
    return (args, )

@wraps(atup2tup)
def vdic2tup(*args: tuple) -> tuple:
    '''A convenience function to accept variadic arguments i.e. 
    an arguments's tuple (`atup`) and ensure that they are represented 
    as a single `tuple`.'''
    return atup2tup(*args)

def mapneeds(*args: NeedCast | Any, __useindex: bool = False, **kwargs: TypeCastingConfig) -> tuple:
    '''Map the `need2tup` function to a sequence of items `args` and return the result as a `tuple`.
    
    Parameters
    ----------
    args : NeedCast
        The sequence of items to map the `need2tup` function to.
        
    __useindex : bool, default: False
        If `True`, the index of the item is used to ensure only the first item in the sequence is cast to a `tuple`.
        Otherwise, all items are cast to a `tuple` if necessary.
        
    **kwargs : TypeCastingConfig
        Additional keyword arguments to pass to `need2tup`.
        
    Returns
    -------
    tuple
        The result of mapping the `need2tup` function to the sequence of items `args`.
        
    Examples
    --------
    >>> mapneeds(1, 2, 3)
    (1, 2, 3)
    >>> mapneeds((1, 2), 3)
    ((1, 2), 3)
    >>> mapneeds(dict(a=1, b=2))
    ({'a': 1, 'b': 2}, )
    >>> mapneeds(dict(a=1, b=2), __dict=True)
    (('a', 'b'), )
    >>> mapneeds(dict(a=1, b=2).keys())
    (('a', 'b'), )
    >>> mapneeds(dict(a=1, b=2).keys(), __dict_keys=False)
    (dict_keys(['a', 'b']), )
    '''
    kwargs.update(__useindex=__useindex)
    caster = partial(need2tup, **kwargs)
    return tuple(caster(arg, __index=i) for i, arg in enumerate(args))
