# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/01_varg.ipynb.

# %% auto 0
__all__ = ['vargsmeta', 'vargs']

# %% ../nbs/01_varg.ipynb 6
from itertools import zip_longest
from _collections_abc import dict_keys, dict_values, dict_items

# %% ../nbs/01_varg.ipynb 8
from typing import Any, Union, TypeAlias, ParamSpec, ClassVar, TypeGuard, Type, Self, Iterable

# %% ../nbs/01_varg.ipynb 10
#| export


# %% ../nbs/01_varg.ipynb 12
from chck import notnone, istuple, isrange, isdictiter

# %% ../nbs/01_varg.ipynb 14
from .core import jointups

# %% ../nbs/01_varg.ipynb 16
#| export


# %% ../nbs/01_varg.ipynb 17
class vargsmeta(type):
    itertypes: ClassVar[tuple[type, ...]] = tuple, range, dict_keys, dict_values, dict_items
    @classmethod
    def isitertype(cls, x) -> TypeGuard[Union[tuple, range, dict_keys, dict_values, dict_items]]:
        return isinstance(x, cls.itertypes)
    
    def __normalize__(cls, *args) -> tuple:
        if len(args) == 1 and cls.isitertype(args[0]):
            return cls.__normalize__(*args[0])
        
        args = tuple((tuple(a) if cls.isitertype(a) else a) for a in args)
        return args if isinstance(args, tuple) else (args, )
    

# %% ../nbs/01_varg.ipynb 18
class vargs(tuple, metaclass=vargsmeta):
    '''A tuple subclass that wrangles and normalizes `*args` into a tuple of arguments
    
    Examples
    --------
    >>> Recursive deconstruction
    >>> vargs(1), vargs((1, )), vargs(((1, ), ))
    ((1,), (1,), (1,))

    >>> # Deconstruct only the first argument, tuples ok at other positions
    >>> vargs(1, 2), vargs('a', (1, )), vargs('a', 1, ), vargs(*['a'])
    ((1, 2), ('a', (1,)), ('a', 1), ('a',))

    >>> # handle unpacking
    >>> vargs([]), vargs(*[])
    (([],), ())
    '''
    def __new__(cls: Type[Self], *args: Iterable) -> Self:
        std = cls.__normalize__(*args)
        new = super(vargs, cls).__new__(cls, std)
        return new
    
    @classmethod
    def join(cls, *tuples) -> tuple:
        return cls(jointups(*tuples))
            # next((x for x in item if (x is not None)), None) 
            # for item in zip_longest(*tuples))
    
    @classmethod
    def fill(cls, *args, n: int = 1, pad = None) -> tuple:
        '''Return `args` with `pad` values appended until length is `n`'''
        return cls(args) + cls((pad, ) * (n - len(args)))
    
    @classmethod
    def pack(cls, *args, n: int = 1) -> tuple:
        '''Pack `args` into a tuple of length `n`'''
        return cls.fill(*args, n=n, pad=None)        
