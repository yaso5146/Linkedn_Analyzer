# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/02_util.ipynb.

# %% auto 0
__all__ = ['trysig', 'getsig', 'setsig', 'newtype']

# %% ../nbs/02_util.ipynb 5
from inspect import Signature, signature
from functools import wraps

# %% ../nbs/02_util.ipynb 7
from types import MethodWrapperType
from typing import (Union, Callable, Optional)

# %% ../nbs/02_util.ipynb 9
from nchr import NIL
from nlit import __ANNOTATIONS__, __CALL__, __DOC__, __INIT__, __NEW__,  __NAME__, __SIGNATURE__

# %% ../nbs/02_util.ipynb 11
from .atyp import Types, Namespace

# %% ../nbs/02_util.ipynb 14
def makegetter(attr: str, retself: bool = False) -> Callable:
    @wraps(getattr)
    def get(obj: object, default = None) -> object:
        return getattr(obj, attr, obj if retself else default)
    return get

dunann, duncal, dundoc, dunini, dunnew, dunsig = map(makegetter, (
    __ANNOTATIONS__, __CALL__, __DOC__, __INIT__, __NEW__, __SIGNATURE__))

dunname = makegetter(__NAME__, True)

# %% ../nbs/02_util.ipynb 16
def trysig(o: object) -> Optional[Signature]:
    '''Attempt to retrieve the signature of an object.'''
    try: 
        return signature(o)
    except: 
        ...

def getsig(o: object) -> Signature:
    '''Retrieve the signature of an object, attempting multiple strategies if necessary.'''
    # NOTE: desparate try to get a signature from anywhere
    duns = (dunsig, duncal, dunini, dunnew, dunann)
    vals = {dunname(fn): fn(o) for fn in (lambda x: x, *duns)}
    for _, val in vals.items():
        if (sig := trysig(val)): return sig
        
    # NOTE: if all else fails, try to get a signature from the annotations
    for _, val in vals.items():
        if (sig := dunsig(val)): 
            return sig
    return Signature([])

def setsig(wrapper: MethodWrapperType, attr: Callable) -> MethodWrapperType:
    '''Set the signature of a method wrapper based on an attribute's signature.'''
    sig = getsig(attr)
    setattr(wrapper, __SIGNATURE__, sig)
    
    if hasattr(wrapper, __CALL__) and hasattr(duncal(wrapper), __SIGNATURE__): 
        wrapper.__call__.__signature__ = sig
    if hasattr(wrapper, __INIT__) and hasattr(dunini(wrapper), __SIGNATURE__): 
        wrapper.__init__.__signature__ = sig
    
    setattr(wrapper, __ANNOTATIONS__, dunann(attr, dunann(wrapper)))
    setattr(wrapper, __DOC__, dundoc(attr, dundoc(wrapper)))
    return wrapper

# %% ../nbs/02_util.ipynb 18
def newtype(
    name: str = NIL,
    bases: Union[Types, type] = tuple(), 
    space: Namespace = dict(),
    *, 
    cls: Optional[type] = None, 
    **kwargs
) -> type:
    '''
    Create a new type using type.__new__.

    Parameters
    ----------
    name : str
        The name of the type.

    bases : Union[Types, type]
        A tuple containing base classes of the new type, or a single base class.
        
    space : Union[dict, namespace]
        A dictionary containing attributes and methods of the new type.

    cls : Optional[type]
        A metaclass for the new type, defaults to None.

    **kwargs
        Additional keyword arguments to be included in the type's dictionary.

    Returns
    -------
    type
        The newly created type.

    Notes
    -----
    Calls `newtype` is equvialent to either

    type(name, bases, dict) : 
        if no class `cls` is provided, or

    type.__new__(cls, name, bases, dict) : 
        if a class `cls` is provided.
    '''
    space.update(kwargs)
    if not isinstance(bases, tuple):
        bases = tuple((bases, ))
        
    if cls is None:
        return type(name, tuple(bases), space)
    
    return type.__new__(cls, name, tuple(bases), space)
