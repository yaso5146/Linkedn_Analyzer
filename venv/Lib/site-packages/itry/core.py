# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/10_core.ipynb.

# %% auto 0
__all__ = ['tnew', 'imod', 'itry']

# %% ../nbs/10_core.ipynb 5
from inspect import Signature, Parameter, get_annotations, signature
from functools import wraps, partial
from importlib import import_module

# %% ../nbs/10_core.ipynb 7
from types import ModuleType, MethodWrapperType, BuiltinFunctionType, NoneType, FunctionType, MethodType
from typing import (Dict, Type, Union, Tuple, Callable, ForwardRef, Optional, TypeVar, ParamSpec, TypeGuard, TypeAlias)

# %% ../nbs/10_core.ipynb 8
from .atyp import G, T, P, TypeLike, GuardFunc

# %% ../nbs/10_core.ipynb 10
def tnew(
    n: str = '', 
    b: Union[Tuple[type, ...], type] = tuple(), 
    d: dict = dict(), 
    *, 
    c: Optional[type] = None, 
    **kwargs
) -> type:
    '''
    Create a new type using type.__new__.

    Parameters
    ----------
    n : str
        The name of the type.

    b : Union[Tuple[type, ...], type]

        A tuple containing base classes of the new type, or a single base class.
    d : dict
        A dictionary containing attributes and methods of the new type.

    c : Optional[type]
        A metaclass for the new type, defaults to None.

    **kwargs
        Additional keyword arguments to be included in the type's dictionary.

    Returns
    -------
    type
        The newly created type.

    Notes
    -----
    Calls `tnew` is equvialent to either

    type(name, bases, dict) : 
        if no class `c` is provided, or

    type.__new__(c, name, bases, dict) : 
        if a class `c` is provided.
    '''
    d.update(kwargs)
    if not isinstance(b, tuple): b = tuple((b, ))
    return type(n, tuple(b), d) if c is None else type.__new__(c, n, tuple(b), d)


# %% ../nbs/10_core.ipynb 11
from itertools import product
_ann, _cal, _doc, _ini, _new, _sig = \
    '__annotations__', '__call__', '__doc__', '__init__', '__new__', '__signature__'
def _getsig(o: object):
    try: return signature(o)
    except: ...
    try: return signature(getattr(o, _cal, None))
    except: ...
    try: return signature(getattr(o, _cal, None))
    except: ...
    try: return signature(getattr(o, _ini, None))
    except: ...
    try: return signature(getattr(o, _new, None))
    except: ...
    try: return signature(getattr(o, _sig, None))
    except: ...
    try: return signature(getattr(o, _cal, None))
    except: ...
    sig = getattr(o, _sig, None)
    if sig is None: sig = getattr(getattr(o, _cal, None), _sig, None)
    if sig is None: sig = getattr(getattr(o, _ini, None), _sig, None)
    if sig is None: sig = getattr(getattr(o, _new, None), _sig, None)
    if sig is None: sig = getattr(getattr(o, _ann, None), _sig, None)
    if sig is None: sig = Signature([])
    return sig

def _getsig(o: object):
    # NOTE: desparate try to get a signature from anywhere
    gets = (lambda x: getattr(x, k, None) for k in (_sig, _cal, _ini, _new, _ann))
    for fn in (lambda x: x, *gets):
        try: return signature(fn(o))
        except: ...
    # NOTE: if all else fails, try to get a signature from the annotations
    for fn in (lambda x: x, *gets):
        sig = getattr(fn(o), _sig, None)
        if sig is not None: return sig
        getattr(getattr(o, _cal, None), _sig, None)
    return Signature([])

def _setsig(wrapper: Callable, attr: Callable) -> Callable:
    sig = _getsig(attr)
    wrapper.__signature__ = sig
    if hasattr(wrapper, _cal): wrapper.__call__.__signature__ = sig
    if hasattr(wrapper, _ini): wrapper.__init__.__signature__ = sig
    
    setattr(wrapper, _ann, getattr(attr, _ann, getattr(wrapper, _ann, None)))
    setattr(wrapper, _doc, getattr(attr, _doc, getattr(wrapper, _doc, None)))
    return wrapper

# %% ../nbs/10_core.ipynb 12
def imod(
    name: str, 
    attr: Optional[str] = None,
    bases: Union[Tuple[Type, ...], Type] = tuple(), 
    namespace: Dict[str, T] = dict(),
    default: T = None,
    **kwargs
) -> Union[Type, T]:
    '''
    Import a specific attribute from a module or return a default value if import fails.

    Parameters
    ----------
    name : str
        The name of the module to import from.
    attr : Optional[str]
        The name of the attribute to import from the module, defaults to None.
    bases : Union[Tuple[type, ...], type]
        Base classes for creating a new type if import fails and default is None.
    namespace : dict
        A namespace dictionary for creating a new type.
    default : Optional[type]
        A default value to return if import fails.
    **kwargs
        Additional keyword arguments passed to tnew.

    Returns
    -------
    Optional[type]
        The imported attribute, or the default value, or a new type created using tnew.
    '''
    cls = kwargs.pop('cls', None)
    if not isinstance(bases, tuple): bases = (bases, )
    
    try: 
        mod = import_module(name)
        attr = getattr(mod, attr) if attr is not None else mod
        if isinstance(attr, (FunctionType, MethodType, BuiltinFunctionType, )):
            @wraps(attr)
            def wrapper(*args, **kwargs): return attr(*args, **kwargs)
            wrapper = _setsig(wrapper, attr)
            return wrapper
        else: return attr
    
    except (ImportError, AttributeError):
        if default is not None: return default
        try: return namespace.get(attr, tnew(attr, bases, namespace, c=cls, **kwargs))
        except TypeError: return default

# %% ../nbs/10_core.ipynb 13
def itry(
    name: str, 
    *attrs: str, 
    bases: Union[Tuple[Type, ...], Type] = tuple(), 
    namespace: Dict[str, T] = dict(), 
    **kwargs
) -> Tuple[Union[Type, T], ...]:
    '''
    Try to import multiple attributes from a module, returning a tuple of results.

    Parameters
    ----------
    name : str
        The name of the module to import from.

    attrs : str
        Variable number of attribute names to import from the module.

    bases : Union[Tuple[type, ...], type]
        Base classes for creating new types if import fails.

    namespace : dict
        A namespace dictionary for creating new types.

    **kwargs
        Additional keyword arguments passed to imod.

    Returns
    -------
    Tuple[Optional[type], ...]
        A tuple of the imported attributes or default values.
    '''
    return tuple(imod(name, attr, bases, namespace, **kwargs) for attr in attrs)  
