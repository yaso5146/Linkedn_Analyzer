# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/04_iatt.ipynb.

# %% auto 0
__all__ = ['ImportedAttribute', 'iattr', 'iattrs']

# %% ../nbs/04_iatt.ipynb 5
from functools import wraps

# %% ../nbs/04_iatt.ipynb 7
from typing import (Self, Type, Union, Optional, ClassVar, Iterable)

# %% ../nbs/04_iatt.ipynb 9
from pdec import slotprops, Property
from nlit import ASSET, AREPR, IMPORTED, DEFAULT

# %% ../nbs/04_iatt.ipynb 11
from .cons import (_AREPR, _ASSET, _IMPORTED)
from .atyp import T, Types, Namespace, ImportedAsset
from .util import Spec
from .imod import imod

# %% ../nbs/04_iatt.ipynb 14
@slotprops(dict(
    asset = Property(ASSET, ImportedAsset, doc = 'The imported asset', gen = lambda self: self.__import__()),
    arepr = Property(AREPR, ImportedAsset, doc = 'String representation of the imported asset.', gen = lambda self: self.__asset_repr__()),
    imported = Property(IMPORTED, bool, False, 'Indicates if the import was successful.'),
))
class ImportedAttribute:
    '''A class representing an attribute imported from a module.

    Attributes
    ----------
    name : ClassVar[str]
        The name of the module or attribute.
        
    attr : ClassVar[Optional[str]]
        The specific attribute to import, if any.
        
    bases : ClassVar[Union[Types, type]]
        Base classes for creating new types if import fails.
        
    namespace : ClassVar[Namespace]
        A namespace dictionary for creating new types.
        
    default : ClassVar[Optional[T]]
        Default value if the import fails.
        
    asset : ImportedAsset, optional
        Property for the imported asset.
        
    arepr : str, optional
        Property for the string representation of the imported asset.
        
    imported : bool, default = False
        Property indicating if the import was successful.

    Methods
    -------
    io(ins: 'ImportedAttribute')
        Import an instance of ImportedAttribute class.
        
    ib(bases: Types)
        Import bases using the `io` method.
        
    __init__(self, name, attr, bases, namespace, default, eager, **kwargs)
        Initialize the ImportedAttribute instance.
        
    __import__(self)
        Import the asset using the `imod` method.
        
    __asset_repr__(self)
        Return the string representation of the asset.
        
    __call__(self, *args, **kwargs)
        Call the imported asset if callable.
        
    __repr__(self)
        Return the string representation of the ImportedAttribute instance.
        
    __getitem__(self, key)
        Get an item from the imported asset.
        
    __getattribute__(self, __name)
        Override getattribute to prioritize the asset's attributes.
    '''
    name: ClassVar[str]
    attr: ClassVar[Optional[str]] = None
    bases: ClassVar[Union[Types, type]] = tuple()
    namespace: ClassVar[Namespace] = dict()
    default: ClassVar[Optional[T]] = None
    
    asset: ImportedAsset
    arepr: Optional[str]
    imported: bool
    
    @classmethod
    def io(cls: Type[Self], ins: 'ImportedAttribute') -> ImportedAsset:
        '''Import instance of Imported Attribute class'''
        if not isinstance(ins, cls): 
            return ins
        if not isinstance(ins, ImportedAttribute): 
            return ins
        return ins.__import__()
    
    @classmethod
    def ib(cls: Type[Self], bases: Types = tuple()) -> Types:
        '''Import bases using `io` method which is fault tolerant'''
        if not isinstance(bases, (list, tuple, Iterable)): 
            bases = (bases,)
        return tuple(cls.io(base) for base in bases)
    
    def __init__(
        self: Self, 
        name: str, 
        attr: Optional[str] = None, 
        bases: Types = tuple(), 
        namespace: Namespace = dict(), 
        default: Optional[T] = None, 
        eager: bool = False, 
        **kwargs
    ):
        spec = Spec(name, attr, bases, namespace, default)
        spec.setvals(self, __type = False, **kwargs)
        self._imported = False
        if eager:
            self.__import__()
            
    def __import__(self: Self) -> ImportedAsset:
        '''Import asset using `imod` method which is fault tolerant. 
        
        If any of the classes in `self.bases` are `ImportedAttribute` instances,
        they will be imported first and then passed to `imod` as bases.
        '''
        if getattr(self, _ASSET, None) is not None:
            return self.asset
        
        if getattr(self, _IMPORTED, False):
            return self.asset
        
        asset = imod(self.name, self.attr, self.ib(self.bases), self.namespace, self.default)
        self._asset = asset

        
        if getattr(self, _ASSET, None) != getattr(self, DEFAULT, None): 
            self._imported = True
            
        return self.asset
        return self._asset
    
    def __asset_repr__(self: Self) -> Optional[str]:
        '''Return repr of asset if it exists, otherwise return None.'''
        if not hasattr(self, _AREPR): 
            return None
        
        if getattr(self, _AREPR, None) is None: 
            return repr(self._asset)
        
        return self._arepr
    
    def __call__(self: Self, *args, **kwargs) -> ImportedAsset:
        try:
            
            if callable(self.asset): 
                return self.asset(*args, **kwargs)
        except: 
            ...
        return self.asset
        
    def __repr__(self) -> str:
        return self.arepr or f'{self.name}({self.attr})'
    
    def __getitem__(self: Self, key: str) -> ImportedAsset:
        if hasattr(self, _ASSET): 
            return getattr(self._asset, key)
        
        return getattr(self, key, self.default)
    
    def __getattribute__(self: Self, __name: str, __recursed: bool = False):
        # prioritize self first
        try: 
            return super().__getattribute__(__name)
        except AttributeError as err:
            if __recursed:
                raise err
        # then try asset
        try:
            asset = object.__getattribute__(self, _ASSET)
            return object.__getattribute__(asset, __name)
        
        except AttributeError:
            ...
        # then back to self and raise error if not found
        return self.__getattribute__(__name, True)
        return super().__getattribute__(__name)
    
    
# Alias for `ImportedAttribute` class
@wraps(ImportedAttribute, updated=())
class iattr(ImportedAttribute):
    '''An alias for the ImportedAttribute class.'''

# %% ../nbs/04_iatt.ipynb 21
def iattrs(
    name: str, 
    *attrs: str, 
    bases: Union[Types, type] = tuple(), 
    namespace: Namespace = dict(), 
    **kwargs
) -> tuple[ImportedAttribute, ...]:
    '''Try to import multiple attributes from a module, returning a tuple of results.

    Parameters
    ----------
    name : str
        The name of the module to import from.

    attrs : str
        Variable number of attribute names to import from the module.

    bases : Union[Tuple[type, ...], type]
        Base classes for creating new types if import fails.

    namespace : dict
        A namespace dictionary for creating new types.

    **kwargs
        Additional keyword arguments passed to imod.

    Returns
    -------
    Tuple[ImportedAttribute, ...]
        A tuple of the imported attributes or default values.
    '''
    return tuple(iattr(name, attr, bases, namespace, **kwargs) for attr in attrs)

