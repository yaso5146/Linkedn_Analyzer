# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/00_core.ipynb.

# %% auto 0
__all__ = ['stringmeta', 'template', 'underscoreless', 'private', 'sunder', 'mangled', 'dunder']

# %% ../nbs/00_core.ipynb 6
from abc import abstractmethod
from operator import attrgetter

# %% ../nbs/00_core.ipynb 8
from typing import (Any, Self, Type, TypeGuard, ClassVar,)

# %% ../nbs/00_core.ipynb 10
#| export


# %% ../nbs/00_core.ipynb 12
from nchr import U1, U2, NIL

# %% ../nbs/00_core.ipynb 14
#| export


# %% ../nbs/00_core.ipynb 16
class stringmeta(type):
    '''A metaclass for strings to extend instance checks and equality.

    This metaclass enables the creation of string subclasses with customized behavior for 
    instance checks (`isinstance`) and equality checks (`==`).

    Methods
    -------
    __guard__(cls, ins)
        Abstract method to be implemented by subclasses. It defines custom instance check logic.
        
    __instancecheck__(self, __instance)
        Overrides instance checks to include custom logic defined in __guard__.
        
    __eq__(self, ins)
        Overrides equality check.
        
    __hash__(self)
        Returns the hash of the instance.
    '''
    
    @classmethod
    @abstractmethod
    def __guard__(cls: Type[Self], ins: object) -> TypeGuard[Type[Self]]:
        '''Abstract method to be implemented by subclasses.'''
        ...
        
    def __instancecheck__(self: Self, __instance: object) -> bool:
        '''Overrides instance checks to include custom logic defined in `__guard__`.'''
        return str.__instancecheck__(__instance) and self.__guard__(__instance)
    
    def __eq__(self: Self, ins: object) -> bool:
        '''Overrides equality check to include custom logic defined in `__guard__` via `__instancecheck__`.'''
        if isinstance(ins, self): 
            return True
        
        try: 
            return super().__eq__(ins)
        
        except: 
            ...
            
        try: 
            return str.__eq__(self, ins)
        
        except: 
            return False
       
    def __hash__(self: Self) -> int: 
        '''Returns the hash of the instance.'''
        return super().__hash__()

# %% ../nbs/00_core.ipynb 18
class template(str, metaclass=stringmeta):
    '''
    Base class for custom string types, extending instance checks and equality.

    This class serves as a foundation for creating custom string types with enhanced functionalities 
    like modified instance and equality checks. Inherits from `str` and uses `stringmeta` as its metaclass.

    Attributes
    ----------
    scrub : ClassVar[str]
        Characters to be removed from the string.
        
    brace : ClassVar[str]
        Characters to be stripped from the string.
        
    prefix : ClassVar[str]
        Prefix to be added to the string.
        
    suffix : ClassVar[str]
        Suffix to be added to the string.
        
    presep : ClassVar[str]
        Separator for splitting the prefix into parts.
        
    sufsep : ClassVar[str]
        Separator for splitting the suffix into parts.

    Methods
    -------
    __new__(cls, val)
        Creates a new instance of the class with transformed string value.
        
    __prepare__(val)
        Prepares the string by scrubbing and trimming as per class attributes.
        
    __transform__(val)
        Transforms the string by adding prefixes and suffixes.
        
    get(o, default=None)
        Retrieves the attribute value corresponding to the string from a given object.
    '''
    scrub: ClassVar[str]  = NIL # The characters to be dropped from the string
    brace: ClassVar[str]  = NIL # The characters to be stripped from the string
    prefix: ClassVar[str] = NIL # The character used to prefix the string
    suffix: ClassVar[str] = NIL # The character used to suffix the string
    presep: ClassVar[str] = NIL # The separator used to split the prefix into parts
    sufsep: ClassVar[str] = NIL # The separator used to split the suffix into parts
    
    @property
    def raw(self: Self) -> str:
        '''The raw string.'''
        return self._raw
    
    @classmethod
    def pre(cls) -> str:
        '''The f`{prefix}{presep}` string.'''
        return cls.prefix + (cls.presep if bool(cls.prefix) else NIL)
    
    @classmethod
    def suf(cls) -> str:
        '''The f`{sufsep}{suffix}` string.'''
        return (cls.sufsep if bool(cls.suffix) else NIL) + cls.suffix
    
    @classmethod
    def ldrop(cls, val: str) -> str:
        '''Removes the prefix from the string.'''
        while (prefix := cls.pre()) and val.startswith(prefix): 
            val = val[len(prefix):]
        return val
    
    @classmethod
    def rdrop(cls, val: str) -> str:
        '''Removes the suffix from the string.'''
        while (suffix := cls.suf()) and val.endswith(suffix): 
            val = val[:-len(suffix)]
        return val
    
    @classmethod
    @abstractmethod
    def __prepare__(cls: Type[Self], val: str) -> str:
        '''Abstract method to transform the string value, called before `__transform__`.'''
        val = val.replace(cls.scrub, NIL)
        val = val.strip(cls.brace)
        val = cls.ldrop(val)
        val = cls.rdrop(val)
        return val
    
    @classmethod
    @abstractmethod
    def __transform__(cls: Type[Self], val: str) -> str:
        '''Abstract method to transform the string value, called before `__transform__`.'''
        prefix, suffix = cls.pre(), cls.suf()
        return f'{prefix}{val}{suffix}'
        
    def __new__(cls: Type[Self], val: str):
        val = cls.__prepare__(val)
        val = cls.__transform__(val)
        new = super().__new__(cls, val)
        new._raw = val
        return new
        
    def get(self: Self, o: object, default: Any = None) -> Any:
        '''Get the value of the string attribute from the specified object.'''
        return getattr(o, self, default)
    
    def __call__(self: Self, o: object, default: Any = None) -> Any: 
        return self.get(o, default)
    
    @classmethod
    def __guard__(cls: Type[Self], ins: str) -> TypeGuard[Type[Self]]:
        prefix, suffix = cls.pre(), cls.suf()
        return ins.startswith(prefix) and ins.endswith(suffix)
    
    @classmethod
    def chain(cls, *strs: str):
        raws = [getattr(s, 'raw', s) for s in strs]
        mods = [cls(s) for s in raws]
        same = cls.pre() == cls.suf()
        psep, ssep = (NIL, NIL) if same else (cls.presep, cls.sufsep)
        for i, mod in enumerate(mods):
            if i == 0: mod = f'{cls.rdrop(mod)}{ssep}'
            
            if i != 0 and i != len(mods) - 1:
                # if prefix and suffix are the same, then the suffix of 
                # the previous string is the prefix of the next
                mod = f'{cls.presep}{cls.ldrop(mod)}'
                mod = f'{cls.rdrop(mod)}{ssep}'
                    
            if i == len(mods) - 1 and same: mod = f'{psep}{cls.ldrop(mod)}'
            mods[i] = mod
        return cls(NIL.join(mods))
    
    def lchain(self: Self, *strs: str) -> Type[Self]: 
        return self.chain(self, *strs)
    
    def rchain(self: Self, *strs: str) -> Type[Self]: 
        return self.chain(*strs, self)

    def __add__(self, other) -> str:
        if isinstance(other, type(self)): return self.lchain(other)
        else: return super().__add__(other)
    
    def __radd__(self, other: str) -> str: return self.rchain(other)
    
    
    def __str__(self) -> str: 
        return str.__str__(self)
        return super().__str__()
    
    def __repr__(self) -> str:
        return str.__repr__(self)
        return super().__repr__()

# %% ../nbs/00_core.ipynb 20
class underscoreless(template):
    '''A subclass of template that removes leading underscores from the string.'''
    brace: ClassVar[str] = U1

# %% ../nbs/00_core.ipynb 22
class private(underscoreless):
    '''Represents a private string i.e. a string with a leading underscore (`'_{anything}'`).'''
    prefix: ClassVar[str] = U1
    
    @classmethod
    def __guard__(cls: Type[Self], ins: str) -> TypeGuard[Type[Self]]:
        '''Check if `s` is a private string e.g. `'_{anything}'`.'''
        b, m, e = ins.partition(U1)
        around = ins.startswith(U1) and len(ins) > 1
        inside = b == NIL and m == U1 and not e.startswith(U1) and not e.endswith(U1)
        return around and inside

# %% ../nbs/00_core.ipynb 24
class sunder(underscoreless):
    '''Represents a sunder string i.e. a string with surrounding single underscores (`'_{anything}_'`).'''
    prefix: ClassVar[str] = U1
    suffix: ClassVar[str] = U1
    
    @classmethod
    def __guard__(cls: Type[Self], ins: str) -> TypeGuard[Type[Self]]:
        '''Check if `s` is an sunder string e.g. `'_{anything}_'`.'''
        b, m, e = ins.partition(U1)
        around = ins.startswith(U1) and ins.endswith(U1) and len(ins) > 2
        inside = b == NIL and m == U1 and not e.startswith(U1) and not e.endswith(U1)
        return around and inside

# %% ../nbs/00_core.ipynb 26
class mangled(underscoreless):
    '''Represents a mangled string i.e. a string with a leading double underscore (`'__{anything}'`).'''
    prefix: ClassVar[str] = U2
    
    @classmethod
    def __guard__(cls: Type[Self], ins: str) -> TypeGuard[Type[Self]]:  
        '''Check if `s` is an mangled string e.g. `'__{anything}'`.'''
        b, m, e = ins.partition(U2)
        around = ins.startswith(U2) and len(ins) > 2
        inside = b == NIL and m == U2 and not e.startswith(U2) and not e.endswith(U2)
        return around and inside


# %% ../nbs/00_core.ipynb 28
class dunder(underscoreless):
    '''Represents a dunder string i.e. a string with surrounding double underscores (`'__{anything}__'`).'''
    prefix: ClassVar[str] = U2
    suffix: ClassVar[str] = U2

    @classmethod
    def __guard__(cls: Type[Self], ins: str) -> TypeGuard[Type[Self]]:   
        '''Check if `s` is an dunder string e.g. `'__{anything}__'`.'''  
        b, m, e = ins.partition(U2)
        around = ins.startswith(U2) and ins.endswith(U2) and len(ins) > 4
        inside = b == NIL and m == U2 and not (e.startswith(U2) or e.startswith(U1))
        return around and inside
