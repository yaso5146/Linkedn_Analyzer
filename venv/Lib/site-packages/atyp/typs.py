# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/00_typs.ipynb.

# %% auto 0
__all__ = ['T', 'P', 'matr_inst_proxy', 'typs_inst_proxy', 'typs_prot_proxy', 'names', 'attrs', 'anndata', 'augmenter', 'bgraph',
           'brownian', 'dgraph', 'gtbase', 'gtdata', 'ito', 'kgraph', 'klgraph', 'lgraph', 'matr', 'mgraph', 'mlgraph',
           'nan', 'neurode', 'neursde', 'nonetype', 'npNAN', 'npNaN', 'nparray', 'npbool', 'npempty', 'npmatrix',
           'npnan', 'number', 'odefn', 'pdcatindex', 'pddataframe', 'pdindex', 'pdna', 'pdseries', 'pldatamodule',
           'plmodule', 'ptbooltensor', 'ptdataloader', 'ptdataset', 'ptdevice', 'ptfloattensor', 'ptinttensor',
           'ptmodule', 'ptnan', 'ptsize', 'pttensor', 'pttensorbase', 'pttype', 'recarray', 'repattern', 'sdefn',
           'sparray', 'spmatrix', 'strtemplate', 'tgraph', 'tlgraph', 'array', 'bool01', 'boolic', 'boolindex', 'bools',
           'brownianintervial', 'catindex', 'datatype', 'dim1', 'dim2', 'dim3', 'dim4', 'dimmed', 'floatq', 'floats',
           'graphtype', 'groupkey', 'indexlike', 'indextype', 'intq', 'ints', 'iternum', 'iterstr', 'itertype', 'matrs',
           'nanq', 'nans', 'nantensor', 'neuraldynamics', 'neuralode', 'neuralsde', 'nilstr', 'nnmodule', 'none',
           'notnilstr', 'notstrbytes', 'num', 'numq', 'nums', 'numstr', 'odefunc', 'pttn', 'real', 'realq', 'reals',
           'sdefunc', 'sdeito', 'serialized', 'serieslike', 'seriestype', 'shaped', 'size', 'strbytes', 'strq', 'strs',
           'strtmpl', 'tensor', 'BoolFunc', 'BoolCall', 'BoolCalls', 'BoolFuncQ', 'BoolCallQ', 'Numeric', 'Numbers',
           'NumStr', 'EmptyString', 'NotEmptyEmptyString', 'StrTmpl', 'StrLike', 'Pttn', 'PttnDict', 'StrBytes',
           'NotStrBytes', 'PathType', 'PathLike', 'DirPath', 'DirNames', 'FileNames', 'WalkTuple', 'WalkParts',
           'EnumAuto', 'EnumDict', 'EnumMember', 'Intum', 'Strum', 'Inhum', 'ByteLike', 'Literals', 'TypingLike',
           'GuardLike', 'Module', 'Loader', 'ModuleSpec', 'Sig', 'Param', 'Logger', 'ArgsType', 'SysExcInfoType',
           'FormatStyle', 'ClsInt', 'ClsSet', 'ClsStr', 'ClsObj', 'ClsBool', 'ClsBoolish', 'ClsCall', 'ClsType',
           'ClsList', 'ClsFloat', 'ClsNumber', 'ClsComplex', 'TypeLike', 'GuardFunc', 'StrGuard', 'IterStr', 'IterNum',
           'IterBool', 'ListStr', 'ListNum', 'ListBool', 'Strs', 'Nums', 'Bools', 'SetStr', 'SetNum', 'SetBool',
           'SliceSpec', 'SliceSpecs', 'Slc', 'Slcs', 'RichTree', 'RichText', 'RichCons', 'RichProg', 'RichTask', 'TQDM',
           'Axes', 'ColorMap', 'CBarPos', 'Grid', 'TyperApp', 'Adata', 'Adatas', 'AnnData', 'AnnDatas', 'Size', 'dtype',
           'DType', 'TType', 'TrcType', 'TorchType', 'TorchDType', 'DataType', 'Tens', 'Tensor', 'TrcTensor',
           'NanTensor', 'IntTens', 'BoolTens', 'FloatTens', 'IntTensor', 'BoolTensor', 'FloatTensor', 'Device',
           'TorchLayer', 'TorchModule', 'Dataset', 'DataLoader', 'DataModule', 'Img', 'Image', 'ImageLike', 'ImageSize',
           'ImgSize', 'Video', 'VideoCapture', 'VidCap', 'VideoSize', 'VidSize', 'Coordinate', 'Coord', 'Point',
           'XYPos', 'Width', 'Height', 'Rect', 'BBox', 'BoundingBox', 'RGB', 'RGBA', 'Color', 'PathFormatFunc', 'Mixin',
           'NPArray', 'ndarray', 'NPMatrix', 'ndmatrix', 'DataSource', 'Idx', 'Index', 'CIdx', 'CIndex', 'CatIndex',
           'CategoricalIndex', 'BoolIndex', 'BIdx', 'BooleanIndex', 'Series', 'DFrame', 'DataFrame', 'DataFrames',
           'IndexLike', 'SeriesLike', 'IterLike', 'SPArray', 'SPMatrix', 'AnyQ', 'IntQ', 'SetQ', 'StrQ', 'ObjQ',
           'BoolQ', 'DictQ', 'CallQ', 'TypeQ', 'ListQ', 'IterQ', 'FloatQ', 'TupleQ', 'NumberQ', 'ComplexQ', 'StrLikeQ',
           'NumStrQ', 'PttnQ', 'PatternQ', 'LoggerQ', 'ModuleQ', 'PathLikeQ', 'ClsAnyQ', 'ClsIntQ', 'ClsSetQ',
           'ClsStrQ', 'ClsObjQ', 'ClsBoolQ', 'ClsCallQ', 'ClsTypeQ', 'ClsListQ', 'ClsIterQ', 'ClsFloatQ', 'ClsNumberQ',
           'ClsComplexQ', 'RichTreeQ', 'RichTextQ', 'RichConsQ', 'RichProgQ', 'RichTaskQ', 'TQDMQ', 'IdxQ', 'IndexQ',
           'SeriesQ', 'DataFrameQ', 'CatQ', 'CIdxQ', 'CatIndexQ', 'BIdxQ', 'BoolIndexQ', 'IndexLikeQ', 'NPArrayQ',
           'NPMatrixQ', 'SPArrayQ', 'SPMatrixQ', 'AxesQ', 'DTypeQ', 'DeviceQ', 'TensorQ', 'IntTensorQ', 'BoolTensorQ',
           'FloatTensorQ', 'TensQ', 'IntTensQ', 'BoolTensQ', 'FloatTensQ', 'DatasetQ', 'DataLoaderQ', 'DataModuleQ',
           'VidCapQ', 'ImgSizeQ']

# %% ../nbs/00_typs.ipynb 6
import os, pathlib, inspect, importlib
from enum import IntEnum, StrEnum, EnumMeta, _EnumDict, member
from importlib.abc import Loader

# %% ../nbs/00_typs.ipynb 8
from types import ModuleType, TracebackType

from typing import (
    Any, Dict, List, Set, Type, Union, Tuple, Callable, Literal, 
    TypeVar, ClassVar, TypeAlias, ParamSpec, Optional,
    Iterable, ForwardRef, Mapping, TypeGuard
)
T = TypeVar('T')
P = ParamSpec('P')

# %% ../nbs/00_typs.ipynb 10
#| export


# %% ../nbs/00_typs.ipynb 12
from matr import (
    # nan, 
    nonetype, npnan, npNaN, npNAN, pdna, ptnan, number, npbool, repattern, strtemplate, 
    npmatrix, nparray, recarray, npempty, sparray, spmatrix, 
    pdindex, pdseries, pdcatindex, pddataframe, 
    
    ptsize, pttype, ptdevice,
    ptmodule, ptdataset, ptdataloader, 
    pttensorbase, pttensor, ptinttensor, ptbooltensor, 
    ptfloattensor, plmodule, pldatamodule, 
    
    odefn, sdefn, neurode, neursde, augmenter, 
    ito, brownian, 
    anndata, 
    
    gtbase, gtdata, bgraph, dgraph, 
    lgraph, kgraph, tgraph, mgraph, 
    klgraph, mlgraph, tlgraph
)

from matr import matrs, pmod
from typs import (
    itertype, boolic, bool01, bools, 
    intq, ints, floatq, floats, real, realq, reals, num, numq, nums, iternum, 
    none, nan, nanq, nans, 
    numstr, pttn, strtmpl, strq, nilstr, strbytes, notnilstr, notstrbytes, strs, iterstr, 
    size, array, tensor, nantensor, nnmodule, 
    neuralode, neuralsde, neuraldynamics, odefunc, sdefunc, sdeito, brownianintervial, 
    groupkey, indextype, indexlike, catindex, boolindex, 
    seriestype, serieslike, serialized, 
    datatype, shaped, graphtype, 
    dimmed, dim1, dim2, dim3, dim4
)

from typs import Prototype, Opt, Not

# %% ../nbs/00_typs.ipynb 16
import matr.inst
import typs.inst
import typs.prot

matr_inst_proxy = pmod(matr.inst)
typs_inst_proxy = pmod(typs.inst)
typs_prot_proxy = pmod(typs.prot)

names = globals().get('__all__', globals().get('names', [])) or []
attrs = []
_estr = ''
for proxy in (matr_inst_proxy, typs_inst_proxy, typs_prot_proxy):
    proxy.populate(globals())
    names.extend(proxy.names())
    
    for k, v in proxy.attrs().items():
        value_module = str(getattr(v, '__module__', None))
        proxy_module = str(getattr(proxy, '__module__', None))
        core = lambda m: str(m).split('.')[0]
        
        good = (
            value_module == proxy_module or
            proxy_module in [value_module, core(value_module)] or
            core(proxy_module) in [value_module, core(value_module)] or
            value_module == 'abc'
        )
        if good:
            attrs.append((value_module, k, v))
            _estr += f'{k} = {k}\n'
    
__all__ = globals().get('__all__', [])
__all__.extend(names)

# %% ../nbs/00_typs.ipynb 17
anndata = anndata
augmenter = augmenter
bgraph = bgraph
brownian = brownian
dgraph = dgraph
gtbase = gtbase
gtdata = gtdata
ito = ito
kgraph = kgraph
klgraph = klgraph
lgraph = lgraph
matr = matr
mgraph = mgraph
mlgraph = mlgraph
nan = nan
neurode = neurode
neursde = neursde
nonetype = nonetype
npNAN = npNAN
npNaN = npNaN
nparray = nparray
npbool = npbool
npempty = npempty
npmatrix = npmatrix
npnan = npnan
number = number
odefn = odefn
pdcatindex = pdcatindex
pddataframe = pddataframe
pdindex = pdindex
pdna = pdna
pdseries = pdseries
pldatamodule = pldatamodule
plmodule = plmodule
ptbooltensor = ptbooltensor
ptdataloader = ptdataloader
ptdataset = ptdataset
ptdevice = ptdevice
ptfloattensor = ptfloattensor
ptinttensor = ptinttensor
ptmodule = ptmodule
ptnan = ptnan
ptsize = ptsize
pttensor = pttensor
pttensorbase = pttensorbase
pttype = pttype
recarray = recarray
repattern = repattern
sdefn = sdefn
sparray = sparray
spmatrix = spmatrix
strtemplate = strtemplate
tgraph = tgraph
tlgraph = tlgraph
anndata = anndata
array = array
augmenter = augmenter
bgraph = bgraph
bool01 = bool01
boolic = boolic
boolindex = boolindex
bools = bools
brownian = brownian
brownianintervial = brownianintervial
catindex = catindex
datatype = datatype
dgraph = dgraph
dim1 = dim1
dim2 = dim2
dim3 = dim3
dim4 = dim4
dimmed = dimmed
floatq = floatq
floats = floats
graphtype = graphtype
groupkey = groupkey
gtbase = gtbase
gtdata = gtdata
indexlike = indexlike
indextype = indextype
intq = intq
ints = ints
iternum = iternum
iterstr = iterstr
itertype = itertype
ito = ito
kgraph = kgraph
klgraph = klgraph
lgraph = lgraph
# matr = matr
matrs = matrs
mgraph = mgraph
mlgraph = mlgraph
nan = nan
nanq = nanq
nans = nans
nantensor = nantensor
neuraldynamics = neuraldynamics
neuralode = neuralode
neuralsde = neuralsde
neurode = neurode
neursde = neursde
nilstr = nilstr
nnmodule = nnmodule
none = none
nonetype = nonetype
notnilstr = notnilstr
notstrbytes = notstrbytes
npNAN = npNAN
npNaN = npNaN
nparray = nparray
npbool = npbool
npempty = npempty
npmatrix = npmatrix
npnan = npnan
num = num
number = number
numq = numq
nums = nums
numstr = numstr
odefn = odefn
odefunc = odefunc
pdcatindex = pdcatindex
pddataframe = pddataframe
pdindex = pdindex
pdna = pdna
pdseries = pdseries
pldatamodule = pldatamodule
plmodule = plmodule
ptbooltensor = ptbooltensor
ptdataloader = ptdataloader
ptdataset = ptdataset
ptfloattensor = ptfloattensor
ptinttensor = ptinttensor
ptmodule = ptmodule
ptnan = ptnan
ptsize = ptsize
pttensor = pttensor
pttensorbase = pttensorbase
pttn = pttn
real = real
realq = realq
reals = reals
recarray = recarray
repattern = repattern
sdefn = sdefn
sdefunc = sdefunc
sdeito = sdeito
serialized = serialized
serieslike = serieslike
seriestype = seriestype
shaped = shaped
size = size
sparray = sparray
spmatrix = spmatrix
strbytes = strbytes
strq = strq
strs = strs
strtemplate = strtemplate
strtmpl = strtmpl
tensor = tensor
tgraph = tgraph
tlgraph = tlgraph
# abstractmethod = abstractmethod
matr = matr

# %% ../nbs/00_typs.ipynb 19
BoolFunc: TypeAlias = Callable[P, bool01]
'''A type alias for a function that returns a boolean.'''

BoolCall: TypeAlias = Union[bool01, BoolFunc]
'''A type alias for a boolean or a callable that returns a boolean.'''

BoolCalls: TypeAlias = List[BoolCall]
'''A type alias for a list of booleans or callables that each returns a boolean.''';

BoolFuncQ: TypeAlias = Optional[BoolFunc]

BoolCallQ: TypeAlias = Optional[BoolCall]

# %% ../nbs/00_typs.ipynb 21
Numeric = num

Numbers = nums

NumStr = numstr

# %% ../nbs/00_typs.ipynb 23
EmptyString = nilstr
NotEmptyEmptyString = notnilstr
 
StrTmpl: TypeAlias = strtmpl
StrLike: TypeAlias = Union[str, 'strfix', 'fuzstr', 'nymstr', 'synset', 'brvstr', 'strfix']

Pttn: TypeAlias = pttn
PttnDict: TypeAlias = dict[str, pttn]


StrBytes = strbytes
NotStrBytes = notstrbytes

# %% ../nbs/00_typs.ipynb 25
PathType: TypeAlias = Union[pathlib.Path, pathlib.PosixPath]
PathLike: TypeAlias = Union[str, os.PathLike, pathlib.Path, PathType]

# %% ../nbs/00_typs.ipynb 27
DirPath:   TypeAlias = PathLike
DirNames:  TypeAlias = List[PathLike]
FileNames: TypeAlias = List[PathLike]
WalkTuple: TypeAlias = Tuple[DirPath, DirNames, FileNames]
WalkParts: TypeAlias = Iterable[WalkTuple]

# %% ../nbs/00_typs.ipynb 29
EnumAuto: TypeAlias = member
EnumDict: TypeAlias = _EnumDict
EnumMember: TypeAlias = member

Intum: TypeAlias = Union[IntEnum, 'LitIntEnum', 'Intum']
Strum: TypeAlias = Union[StrEnum, 'LitStrEnum', 'Strum', 'LiteralEnum']

Inhum = ForwardRef('Inhum', module='inhum', is_class=True)

# %% ../nbs/00_typs.ipynb 31
ByteLike: TypeAlias = Union[bytes, 'BytesUnit', 'Bytes']

# %% ../nbs/00_typs.ipynb 34
Literals = TypeVar('Literals')
TypingLike: TypeAlias = Union['TTyp', 'TType', 'TypingUnit', 'Typing']
GuardLike: TypeAlias = Union['TTypGuard', 'TTypeGuard']

# %% ../nbs/00_typs.ipynb 36
Module: TypeAlias = ModuleType

# %% ../nbs/00_typs.ipynb 38
Loader: TypeAlias = Loader
ModuleSpec: TypeAlias = importlib.machinery.ModuleSpec

# %% ../nbs/00_typs.ipynb 40
Sig:   TypeAlias = inspect.Signature
Param: TypeAlias = inspect.Parameter

# %% ../nbs/00_typs.ipynb 42
from logging import Logger

# %% ../nbs/00_typs.ipynb 43
Logger: TypeAlias = Logger

ArgsType: TypeAlias = type[tuple[object, ...]] | type[Mapping[str, object]]

SysExcInfoType: TypeAlias = \
    type[tuple[type[BaseException], BaseException, TracebackType | None]] | \
    type[tuple[None, None, None]]

FormatStyle: TypeAlias = Literal['%', '{', '$']

# %% ../nbs/00_typs.ipynb 45
ClsInt = ClassVar[int]
ClsSet = ClassVar[set]
ClsStr = ClassVar[str]
ClsObj = ClassVar[object]

ClsBool = ClassVar[bool]
ClsBoolish = ClassVar[bool01]
ClsCall = ClassVar[Callable]

ClsType = ClassVar[type]
ClsList = ClassVar[list]

ClsFloat = ClassVar[float]
ClsNumber = ClassVar[num]
ClsComplex = ClassVar[complex]

# %% ../nbs/00_typs.ipynb 47
TypeLike:  TypeAlias = Union[Type, TypeAlias, Type[T]]
GuardFunc: TypeAlias = Callable[P, TypeGuard[TypeLike]]
StrGuard: TypeAlias = Callable[[str], TypeGuard[str]]

# %% ../nbs/00_typs.ipynb 49
IterStr: TypeAlias = iterstr
IterNum: TypeAlias = iternum
IterBool: TypeAlias = bools

# %% ../nbs/00_typs.ipynb 51
ListStr: TypeAlias = strs
ListNum: TypeAlias = nums
ListBool: TypeAlias = bools

Strs: TypeAlias = strs
Nums: TypeAlias = nums
Bools: TypeAlias = bools

# %% ../nbs/00_typs.ipynb 53
SetStr: TypeAlias = Set[str]
SetNum: TypeAlias = Set[num]
SetBool: TypeAlias = Set[bool01]

# %% ../nbs/00_typs.ipynb 55
SliceSpec: TypeAlias = Union[slice, tuple]
SliceSpecs: TypeAlias = Tuple[SliceSpec, ...]

Slc: TypeAlias = SliceSpec
Slcs: TypeAlias = SliceSpecs

# %% ../nbs/00_typs.ipynb 57
try:
    from rich.tree import Tree
    from rich.text import Text
    from rich.console import Console
    from rich.progress import Progress, Task
    tree = Tree
    text = Text
    cons = Console
    prog = Progress
    task = Task
    
except ImportError:
    tree = ForwardRef('rich.tree.Tree', module='rich.tree', is_class=True)
    text = ForwardRef('rich.text.Text', module='rich.text', is_class=True)
    cons = ForwardRef('rich.console.Console', module='rich.console', is_class=True)
    prog = ForwardRef('rich.progress.Progress', module='rich.progress', is_class=True)
    task = ForwardRef('rich.progress.Task', module='rich.progress', is_class=True)
    

RichTree: TypeAlias = tree
RichText: TypeAlias = text
RichCons: TypeAlias = cons
RichProg: TypeAlias = prog
RichTask: TypeAlias = task

# %% ../nbs/00_typs.ipynb 59
try: 
    from tqdm.auto import tqdm as auto    
except ImportError: 
    auto = ForwardRef('tqdm.auto.tqdm', module='tqdm.auto', is_class=True)
    
    
TQDM: TypeAlias = auto

# %% ../nbs/00_typs.ipynb 61
try:
    import matplotlib as mpl
    from matplotlib.axes._axes import Axes

    cmap = mpl.colors.Colormap
    axes = Axes

except ImportError:
    cmap = 'matplotlib.colors.Colormap'
    axes = 'matplotlib.axes._axes.Axes'

# %% ../nbs/00_typs.ipynb 62
Axes: TypeAlias = axes
ColorMap: TypeAlias = cmap

CBarPos: TypeAlias = Tuple[float, float, float, float]
'''tuple of (left, bottom, width, height)''';

Grid: TypeAlias = Tuple[int, int]
'''the number of rows and columns of a grid''';

# %% ../nbs/00_typs.ipynb 64
try:
    from typer import Typer
    tapp = Typer    
except ImportError:
    tapp = ForwardRef('typer.Typer', module='typer', is_class=True)
    
TyperApp: TypeAlias = tapp

# %% ../nbs/00_typs.ipynb 66
Adata: TypeAlias = anndata
Adatas: TypeAlias = List[anndata]

AnnData: TypeAlias = anndata
AnnDatas: TypeAlias = List[anndata]

# %% ../nbs/00_typs.ipynb 68
Size: TypeAlias = tuple[int, ...]
Axes: TypeAlias = Union[int, tuple[int, ...]]

# %% ../nbs/00_typs.ipynb 70
dtype: TypeAlias = pttype
DType: TypeAlias = pttype

TType: TypeAlias = pttype
TrcType: TypeAlias = pttype

TorchType: TypeAlias = pttype
TorchDType: TypeAlias = pttype

DataType: TypeAlias = pttype

# %% ../nbs/00_typs.ipynb 72
Tens: TypeAlias = tensor
Tensor: TypeAlias = tensor
TrcTensor: TypeAlias = tensor

# %% ../nbs/00_typs.ipynb 73
NanTensor = nantensor

IntTens: TypeAlias = ptinttensor
BoolTens: TypeAlias = ptbooltensor
FloatTens: TypeAlias = ptfloattensor

IntTensor: TypeAlias = ptinttensor
BoolTensor: TypeAlias = ptbooltensor
FloatTensor: TypeAlias = ptfloattensor

# %% ../nbs/00_typs.ipynb 75
Device: TypeAlias = ptdevice

# %% ../nbs/00_typs.ipynb 77
TorchLayer: TypeAlias = ptmodule
TorchModule: TypeAlias = TorchLayer

# %% ../nbs/00_typs.ipynb 79
Dataset: TypeAlias = ptdataset
DataLoader: TypeAlias = ptdataloader

# %% ../nbs/00_typs.ipynb 81
DataModule: TypeAlias = pldatamodule

# %% ../nbs/00_typs.ipynb 84
try:
    from cv2 import VideoCapture as vidcap
except ImportError:
    vidcap = ForwardRef('cv2.VideoCapture', module='cv2', is_class=True)

# %% ../nbs/00_typs.ipynb 86
try:
    from PIL.Image import Image as image
except ImportError:
    image = ForwardRef('PIL.Image.Image', module='PIL.Image', is_class=True)

# %% ../nbs/00_typs.ipynb 89
Img: TypeAlias = image
Image: TypeAlias = image
ImageLike: TypeAlias = Union[array, Image]

ImageSize: TypeAlias = Union[Tuple[int, int], Tuple[int, int, int]]
ImgSize: TypeAlias = ImageSize

# %% ../nbs/00_typs.ipynb 91
Video: TypeAlias = vidcap
VideoCapture: TypeAlias = Video
VidCap: TypeAlias = Video

VideoSize: TypeAlias = Union[Tuple[int, int, int], Tuple[int, int, int, int]]
VidSize: TypeAlias = VideoSize

# %% ../nbs/00_typs.ipynb 93
Coordinate: TypeAlias = Tuple[Numeric, ...]
Coord: TypeAlias = Coordinate
Point: TypeAlias = Coordinate

XYPos: TypeAlias = Tuple[int, int]

Width: TypeAlias = int
'''the width of an object'''
Height: TypeAlias = int
'''the height of an object'''
Rect: TypeAlias = Tuple[Width, Height]
'''the width and height of a rectangle'''

BBox: TypeAlias = Tuple[XYPos, XYPos]
BoundingBox: TypeAlias = BBox
Size: TypeAlias = Tuple[int, ...]

# %% ../nbs/00_typs.ipynb 95
RGB: TypeAlias = Tuple[int, int, int]
RGBA: TypeAlias = Tuple[int, int, int, int]

Color: TypeAlias = Union[RGB, RGBA]

# %% ../nbs/00_typs.ipynb 98
PathFormatFunc: TypeAlias = Callable[[os.PathLike, strq, strq, strq], str]

# %% ../nbs/00_typs.ipynb 100
Mixin: TypeAlias =  Union[Tuple[Type, Callable], 'MixinType']

# %% ../nbs/00_typs.ipynb 102
try:
    import numpy as np
    arr = np.ndarray
    mtx = np.matrix
    dsr = np.DataSource
    
except ImportError:
    # Define a placeholder type if numpy is not installed
    arr = ForwardRef('numpy.ndarray', module='numpy', is_class=True)
    mtx = ForwardRef('numpy.matrix', module='numpy', is_class=True)
    dsr = ForwardRef('numpy.DataSource', module='numpy', is_class=True)

# %% ../nbs/00_typs.ipynb 103
NPArray: TypeAlias = arr
ndarray: TypeAlias = arr

NPMatrix: TypeAlias = mtx
ndmatrix: TypeAlias = mtx

DataSource: TypeAlias = dsr

# %% ../nbs/00_typs.ipynb 105
try:
    import pandas as pd
    index = pd.Index
    cindex = pd.CategoricalIndex
    
    dframe = pd.DataFrame
    series = pd.Series

except ImportError:    
    # Define a placeholder type if pandas is not installed
    # index = 'pd.Index'    
    # cindex = 'pd.CategoricalIndex'    
    # dframe = 'pd.DataFrame'
    # series = 'pd.Series'
    index  = ForwardRef('pandas.Index', module='pandas', is_class=True)
    cindex = ForwardRef('pandas.CategoricalIndex', module='pandas', is_class=True)
    dframe = ForwardRef('pandas.DataFrame', module='pandas', is_class=True)
    series = ForwardRef('pandas.Series', module='pandas', is_class=True)

# %% ../nbs/00_typs.ipynb 106
Idx: TypeAlias = index
Index: TypeAlias = index

CIdx: TypeAlias = cindex
CIndex: TypeAlias = cindex
CatIndex: TypeAlias = cindex
CategoricalIndex: TypeAlias = cindex

# %% ../nbs/00_typs.ipynb 107
BoolIndex = boolindex

BIdx: TypeAlias = BoolIndex
BooleanIndex: TypeAlias = BoolIndex

# %% ../nbs/00_typs.ipynb 108
Series: TypeAlias = series

DFrame: TypeAlias = dframe
DataFrame: TypeAlias = dframe
DataFrames: TypeAlias = List[DataFrame]

# %% ../nbs/00_typs.ipynb 110
IndexLike = indexlike
SeriesLike = serieslike
IterLike: TypeAlias = Union[Iterable, serieslike, indexlike]

# %% ../nbs/00_typs.ipynb 112
try:
    import scipy as sp
    
    try: sparr = sp.sparse._arrays._sparray
    except AttributeError: sparr = sp.sparse.sparray

    spmtx = sp.sparse.spmatrix

except ImportError:
    # Define a placeholder type if scipy is not installed
    sparr = 'scipy.sparse._base.sparray'
    spmtx = 'scipy.sparse._matrix.spmatrix'

# %% ../nbs/00_typs.ipynb 113
SPArray: TypeAlias = sparray
SPMatrix: TypeAlias = spmatrix

# %% ../nbs/00_typs.ipynb 116
AnyQ: TypeAlias = Optional[Any]
IntQ: TypeAlias = Optional[int]
SetQ: TypeAlias = Optional[set]
StrQ: TypeAlias = Optional[str]
ObjQ: TypeAlias = Optional[object]

BoolQ: TypeAlias = Optional[bool01]
DictQ: TypeAlias = Optional[dict]
CallQ: TypeAlias = Optional[Callable]
TypeQ: TypeAlias = Optional[Type]
ListQ: TypeAlias = Optional[list]
IterQ: TypeAlias = Optional[Iterable]
FloatQ: TypeAlias = Optional[float]
TupleQ: TypeAlias = Optional[tuple]
NumberQ: TypeAlias = Optional[num]
ComplexQ: TypeAlias = Optional[complex]

StrLikeQ: TypeAlias = Optional[StrLike]
NumStrQ: TypeAlias = Optional[numstr]

# %% ../nbs/00_typs.ipynb 118
PttnQ: TypeAlias = Optional[pttn]
PatternQ: TypeAlias = Optional[pttn]

# %% ../nbs/00_typs.ipynb 120
LoggerQ: TypeAlias = Optional[Logger]

# %% ../nbs/00_typs.ipynb 122
ModuleQ: TypeAlias = Optional[Module]

PathLikeQ: TypeAlias = Optional[PathLike]

# %% ../nbs/00_typs.ipynb 124
BoolFuncQ: TypeAlias = Optional[BoolFunc]

BoolCallQ: TypeAlias = Optional[BoolCall]

# %% ../nbs/00_typs.ipynb 126
ClsAnyQ = ClassVar[AnyQ]
ClsIntQ = ClassVar[IntQ]
ClsSetQ = ClassVar[SetQ]
ClsStrQ = ClassVar[StrQ]
ClsObjQ = ClassVar[ObjQ]
ClsBoolQ = ClassVar[BoolQ]
ClsCallQ = ClassVar[CallQ]
ClsTypeQ = ClassVar[TypeQ]
ClsListQ = ClassVar[ListQ]
ClsIterQ = ClassVar[IterQ]
ClsFloatQ = ClassVar[FloatQ]
ClsNumberQ = ClassVar[NumberQ]
ClsComplexQ = ClassVar[ComplexQ]

StrLikeQ: TypeAlias = Optional[StrLike]

# %% ../nbs/00_typs.ipynb 128
RichTreeQ: TypeAlias = Optional[RichTree]
RichTextQ: TypeAlias = Optional[RichText]
RichConsQ: TypeAlias = Optional[RichCons]
RichProgQ: TypeAlias = Optional[RichProg]
RichTaskQ: TypeAlias = Optional[RichTask]
TQDMQ: TypeAlias = Optional[TQDM]

# %% ../nbs/00_typs.ipynb 130
IdxQ: TypeAlias = Optional[Idx]
IndexQ: TypeAlias = Optional[Index]
SeriesQ: TypeAlias = Optional[Series]
DataFrameQ: TypeAlias = Optional[DataFrame]

# %% ../nbs/00_typs.ipynb 131
CatQ: TypeAlias = Optional[CatIndex]
CIdxQ: TypeAlias = Optional[CatIndex]
CatIndexQ: TypeAlias = Optional[CatIndex]


BIdxQ: TypeAlias = Optional[BoolIndex]
BoolIndexQ: TypeAlias = Optional[BoolIndex]
IndexLikeQ: TypeAlias = Optional[IndexLike]

# %% ../nbs/00_typs.ipynb 132
NPArrayQ: TypeAlias = Optional[NPArray]
NPMatrixQ: TypeAlias = Optional[NPMatrix]

SPArrayQ: TypeAlias = Optional[SPArray]
SPMatrixQ: TypeAlias = Optional[SPMatrix]

# %% ../nbs/00_typs.ipynb 134
AxesQ: TypeAlias = Optional[Axes]

# %% ../nbs/00_typs.ipynb 135
DTypeQ: TypeAlias = Optional[DType]
DeviceQ: TypeAlias = Optional[Device]

TensorQ: TypeAlias = Optional[Tensor]
IntTensorQ: TypeAlias = Optional[IntTensor]
BoolTensorQ: TypeAlias = Optional[BoolTensor]
FloatTensorQ: TypeAlias = Optional[FloatTensor]


TensQ: TypeAlias = Optional[Tensor]
IntTensQ: TypeAlias = Optional[IntTensor]
BoolTensQ: TypeAlias = Optional[BoolTensor]
FloatTensQ: TypeAlias = Optional[FloatTensor]

# %% ../nbs/00_typs.ipynb 136
DatasetQ: TypeAlias = Optional[Dataset]
DataLoaderQ: TypeAlias = Optional[DataLoader]
DataModuleQ: TypeAlias = Optional[DataModule]

# %% ../nbs/00_typs.ipynb 138
VidCapQ: TypeAlias = Optional[VidCap]
ImgSizeQ: TypeAlias = Optional[ImgSize]

# %% ../nbs/00_typs.ipynb 139
#| export
