# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/20_mods.ipynb.

# %% auto 0
__all__ = []

# %% ../nbs/20_mods.ipynb 6
#| export


# %% ../nbs/20_mods.ipynb 8
from types import ModuleType

# %% ../nbs/20_mods.ipynb 10
#| export

# %% ../nbs/20_mods.ipynb 12
#| export

# %% ../nbs/20_mods.ipynb 14
from .base import DuckModule

# %% ../nbs/20_mods.ipynb 16
class _os(DuckModule): 
    __duckmodule__ = 'os'
    __alts__ = dict(PathLike=str)

class _pathlib(DuckModule): 
    __duckmodule__ = 'pathlib'
    __alts__ = dict(Path=str, PosixPath=str)
    
class _types(DuckModule):
    __duckmodule__ = 'types'
    __alts__ = dict(ModuleType=type, MethodWrapperType=type, BuiltinFunctionType=type, TracebackType=type, FunctionType=type, NoneType=type(None))
    
class _re(DuckModule):
    __duckmodule__ = 're'
    __alts__ = dict(Pattern=type, Match=type)
    
class _string(DuckModule):
    __duckmodule__ = 'string'
    __alts__ = dict(Template=type, Match=type)
    
class _math(DuckModule): 
    __duckmodule__ = 'math'
    __alts__ = dict(nan=float('nan'))
    
class _numbers(DuckModule): 
    __duckmodule__ = 'numbers'
    __alts__ = dict(Number=type)
    
class _inspect(DuckModule):
    __duckmodule__ = 'inspect'
    __alts__ = dict(Signature=type, Parameter=type, ParameterKind=type, BoundArguments=type)
    
class _importlib(DuckModule):
    __duckmodule__ = 'importlib'
    __alts__ = dict(Loader=type, ModuleSpec=type)
    
class _itertools(DuckModule):
    __duckmodule__ = 'itertools'
    __alts__ = dict(chain=type, product=type, combinations=type, permutations=type, zip_longest=type)
    
class _logging(DuckModule):
    __duckmodule__ = 'logging'
    __alts__ = dict(Logger=type, LogRecord=type, Handler=type, Filter=type, Formatter=type)
    
class _collectionsabc(DuckModule):
    __duckmodule__ = '_collections_abc'
    __alts__ = dict(dict_keys=type, dict_values=type, dict_items=type)
    
class _numpy(DuckModule): 
    __duckmodule__ = 'numpy'
    __alts__ = dict(
        nan=float('nan'), NaN=float('nan'), NAN=float('nan'),
        bool_=bool, dtype=type,
        ndarray=list, matrix=list, recarray=list,
        DataSource=str, empty=None
    )
    
class _scipy(DuckModule):
    __duckmodule__ = 'scipy'
    __alts__ = dict(
        sparray=list, spmatrix=list, 
        cscarray=list, cscmatrix=list,
        cooarray=list, coomatrix=list,
        csrarray=list, csrmatrix=list,
        diaarray=list, diamatrix=list,
        dokarray=list, dokmatrix=list,
        lilarray=list, lilmatrix=list,
        bsrarray=list, bsrmatrix=list,
    )
    
class _pandas(DuckModule):
    __duckmodule__ = 'pandas'
    __alts__ = dict(
        NA=float('nan'), Index=list, DataFrame=list, Series=list, CategoricalIndex=list,
        PandasDelegate=object, CategoricalAccessor=object
    )
    
class _sklearn(DuckModule):
    __duckmodule__ = 'sklearn'
    __alts__ = dict(BaseEstimator=type, pairwise=type)
    
class _torch_c(DuckModule):
    # Appease the type checker; ordinarily this binding is inserted by the
    # torch._C module initialization code in C
    __duckmodule__ = 'torch._C'
    __alts__ = dict(_TensorBase=type)
    
class _torch(DuckModule):
    __duckmodule__ = 'torch'
    __alts__ = dict(
        _C=_torch_c, nn=ModuleType('torch.nn'), optim=ModuleType('torch.optim'),
        size=tuple, dtype=type, device=str, Tensor=list,
        IntTensor=list, FloatTensor=list, LongTensor=list, DoubleTensor=list, BoolTensor=list,
        Module=type, Dataset=list, DataLoader=list,
        memory_format=type, reserve_format=type
    )
    
class _torchvision(DuckModule):
    __duckmodule__ = 'torchvision'
    __alts__ = dict(
        datasets=ModuleType('torchvision.datasets'), 
        transforms=ModuleType('torchvision.transforms'), 
        functional=ModuleType('torchvision.transforms.functional'),
    )
    
class _pytorch_lightning(DuckModule):
    __duckmodule__ = 'pytorch_lightning'
    __alts__ = dict(LightningModule=type, LightningDataModule=type)
    
class _torchdyn(DuckModule):
    __duckmodule__ = 'torchdyn'
    __alts__ = dict(
        NeuralODE=type, NeuralSDE=type, ODEFunc=type, SDEFunc=type, Augmenter=type, 
        nn=ModuleType('torchdyn.nn'), utils=ModuleType('torchdyn.utils')
    )
    
class _torchsde(DuckModule):
    __duckmodule__ = 'torchsde'
    __alts__ = dict(SDEIto=type, BrownianInterval=type)
    
class _anndata(DuckModule):
    __duckmodule__ = 'anndata'
    __alts__ = dict(AnnData=list)
    
class _cv2(DuckModule):
    __duckmodule__ = 'cv2'
    __alts__ = dict(VideoCapture=type)

class _PIL(DuckModule):
    __duckmodule__ = 'PIL'
    __alts__ = dict(Image=type)
    
class _graphtools(DuckModule):
    __duckmodule__ = 'graphtools'
    __alts__ = dict(
        Base=type, Data=type, BaseGraph=type, DataGraph=type,
        LandmarkGraph=type, kNNGraph=type, TraditionalGraph=type, MNNGraph=type,
        kNNLandmarkGraph=type, MNNLandmarkGraph=type, TraditionalLandmarkGraph=type
    )

class _phate(DuckModule):
    __duckmodule__ = 'phate'


class _mpl_base(DuckModule):
    __duckmodule__ = 'matplotlib.axes._base'
    
class _mpl_artist(DuckModule):
    __duckmodule__ = 'matplotlib.artist'
    
class _mpl_axes(DuckModule):
    __duckmodule__ = 'matplotlib.axes._axes'
    
class _mpl_patches(DuckModule):
    __duckmodule__ = 'matplotlib.patches'
    
class _matplotlib(DuckModule):
    __duckmodule__ = 'matplotlib'
    __alts__ = dict(
        pyplot=ModuleType('matplotlib.pyplot'),
        Artist=type, Patch=type, Axes=type,
        ColorMap=type, LinearSegmentedColormap=type, 
    )
    
class _seaborn(DuckModule):
    __duckmodule__ = 'seaborn'
    
class _rich(DuckModule):
    __duckmodule__ = 'rich'
    __alts__ = dict(JupyterMixin=type, Console=type, Table=type, Progress=type, Task=type, Text=type, Tree=type)

class _tqdm(DuckModule):
    __duckmodule__ = 'tqdm'
    __alts__ = dict(Comparable=type, tqdm_asyncio=type, tqdm_notebook=type)

class _typer(DuckModule):
    __duckmodule__ = 'typer'
    __alts__ = dict(Typer=type)
